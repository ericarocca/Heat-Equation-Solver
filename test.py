import numpy as np
import pytest
import configparser
import hypothesis
from hypothesis import strategies as st
from hypothesis import settings
from hypothesis import given
from function import (
    function_temperature, heat_equation_CN,
    heat_equation_analytical, check_stability,
    create_matrices, apply_boundary_conditions,
    validate_stability
)

#numerical test cases
numerical_cases = [
    {"length": 0.5, "time": 0.1, "alpha": 0.01, "nx": 10, "nt": 10},  #short rod, low diffusivity, low resolution
    {"length": 1.0, "time": 0.1, "alpha": 0.4, "nx": 20, "nt": 40},    #short rod, moderate diffusivity, low resolution
    {"length": 0.6, "time": 0.05, "alpha": 0.01, "nx": 50, "nt": 100},  #short rod, low diffusivity, high resolution
    {"length": 3.0, "time": 0.3, "alpha": 1.9, "nx": 20, "nt": 60},    #moderate-length rod, high diffusivity, low resolution
    {"length": 3.0, "time": 0.3, "alpha": 0.9, "nx": 20, "nt": 60},   #moderate-length rod, high diffusivity, low resolution
    {"length": 3.0, "time": 0.2, "alpha": 0.02, "nx": 150, "nt": 300},  #moderate rod, low diffusivity, high resolution
    {"length": 5.0, "time": 0.1, "alpha": 2.0, "nx": 100, "nt": 200},   #long rod, high diffusivity, high resolution
    {"length": 5.0, "time": 0.5, "alpha": 0.8, "nx": 30, "nt": 100},   #long, rod, moderate diffusivity, low resolution
    {"length": 5.0, "time": 0.5, "alpha": 0.1, "nx": 100, "nt": 200},   #long rod, low diffusivity, high resolution

]

@pytest.mark.parametrize("parameters", numerical_cases)
def test_initial_conditions(parameters):
    """
    Test that the initial conditions of the temperature function are respected.
    
    GIVEN: A spatial grid generated by linspace with values ranging from 0 to 1.
    WHEN: Computing the initial temperature using function_temperature.
    THEN: The resulting values should closely match the expected sine function values.

    """
    x = np.linspace(0, 1.0, 20)
    expected_initial =  np.sin(np.pi * x / 1.0)
    actual_initial = np.array([function_temperature(xi, 1.0) for xi in x])
    np.testing.assert_allclose(actual_initial, expected_initial, rtol=1e-3)

@pytest.mark.parametrize(
    "length, time, alpha, nx, nt, expected_valid",
    [
        (1.0, 0.5, 0.1, 10, 20, True),  #stable
        (1.0, 0.5, 0.1, 10, 2, False),  #unstable
        (1.0, 0.1, 1.0, 5, 10, True),   #stable
        (1.0, 0.1, 1.0, 5, 3, False),   #unstable
        (5.0, 1.0, 0.01, 100, 200, True),  #stable
    ],
)
def test_validate_stability(length, time, alpha, nx, nt, expected_valid):
    """
    Test for validating stability with valid and invalid configurations.

    Parameters
    ----------
    length : float
            length of the rod.
    time : float
            time of the evolution.
    alpha : float
            diffusivity coefficient of the medium.
    nx : int
        number of spatial steps.
    nt : int
        number of time steps.
    expected_valid : bool
        true if the configuration is expected to be valid (stable).
    """
    if expected_valid:
        try:
            validate_stability(length, time, nx, nt, alpha)
        except ValueError as e:
            pytest.fail(f"Unexpected ValueError for valid parameters: {locals()} - {str(e)}")
        assert True  
    else: #expect a ValueError for invalid configurations
        with pytest.raises(ValueError, match=r"Unstable configuration: r=\d+\.\d+\. Ensure r < 0\.5\."):
            validate_stability(length, time, nx, nt, alpha)
        assert True 

@pytest.mark.parametrize(
    "length, time, alpha, nx_values, nt_values, expected_count",
    [
        (1.0, 0.5, 0.1, [10, 20, 50], [10, 20], 1),  #1 stable combination expected
        (1.0, 0.5, 0.1, [10, 20], [5, 10], 0),       #0 stable combinations expected
        (1.0, 0.5, 1.0, [5, 10, 15], [5, 10, 15], 0),  #0 stable combinations expected
        (2.0, 0.1, 0.1, [10, 20], [20, 40], 4),  #4 stable combinations expected
    ],
)
def test_check_stability_parametrized(length, time, alpha, nx_values, nt_values, expected_count):
    """
    Test the check_stability function using parameterized inputs.
    
    This test verifies the function's ability to:
    - Correctly identify stable combinations of grid and time steps,
    - Handle cases with no stable combinations,
    - Maintain numerical precision for the stability condition r < 0.5.
    
    Given: A set of inputs for length, time, alpha, nx_values, and nt_values.
    When: The check_stability function is called.
    Then: The number of stable combinations matches the expected count.

    Parameters
    ----------
    length : float
        length of the rod.
    time : float
        time of the evolution.
    alpha : float
        diffusivity coefficient of the medium.
    nx_values : list of int
        list of spatial grid resolutions.
    nt_values : list of int
        list of temporal grid resolutions.
    expected_count : int
        the expected number of stable combinations.
    """

    stable_combinations = check_stability(length, time, alpha, nx_values, nt_values)
    assert len(stable_combinations) == expected_count


@pytest.mark.parametrize("parameters", numerical_cases)
def test_calculate_r(parameters):
    """
    Test that the r parameter is calculated within the correct range.
    
    GIVEN: A set of numerical parameters.
    WHEN: Calculating r using calculate_r.
    THEN: r should fall within the range 0.001≤r≤0.499 to pass the test.

    """
    length = parameters["length"]
    nx = parameters["nx"]
    time = parameters["time"]
    nt = parameters["nt"]
    alpha = parameters["alpha"]

    r = calculate_r(length, time, alpha, nx, nt)
    r_min, r_max = 0.001, 0.499 #acceptable range for r (empirically chosen for good accuracy)
    
    assert r_min <= r <= r_max, f"Parameter r={r:.3f} is outside the acceptable range."

@pytest.mark.parametrize("parameters", numerical_cases)
def test_boundary_conditions(parameters):
    """
    Test that checks the enforcing of boundary conditions on the w array.
    
    GIVEN a set of parameters for length, spatial steps (nx), time, time steps (nt), and diffusivity coefficient (alpha)
          that meet the stability requirements for the Crank-Nicolson heat equation solver,
    WHEN the heat equation is solved using these parameters,
    THEN the boundary conditions should be enforced on the w temperature array, meaning:
         - the temperature at the first position (index 0) along the rod remains 0 for all time steps.
         - the temperature at the last position (index -1) along the rod remains 0 for all time steps.

    """
    length = parameters["length"]
    nx = parameters["nx"]
    time = parameters["time"]
    nt = parameters["nt"]
    alpha = parameters["alpha"]
    
    x, w = heat_equation_CN(length, nx, time, nt, alpha, function_temperature)
    
    assert np.all(w[0, :] == 0)
    assert np.all(w[-1, :] == 0)

@pytest.mark.parametrize("parameters", numerical_cases)
def test_matrices_shape(parameters):
    """
    Test that checks that the w matrix has the expected dimension [nx, nt] for the numerical solution.
    
    GIVEN: A set of parameters for the heat equation (length, nx, time, nt, alpha).
    WHEN: Generating the matrices using heat_equation_CN.
    THEN: The output matrix should have the shape (nx, nt).

    """
    length = parameters["length"]
    nx = parameters["nx"]
    time = parameters["time"]
    nt = parameters["nt"]
    alpha = parameters["alpha"]
    
    x, w = heat_equation_CN(length, nx, time, nt, alpha, function_temperature)
        
    assert w.shape == (nx, nt)


def test_create_matrices():
    """
    Test that the create_matrices function returns matrices A and B with correct properties.
    
    GIVEN: A grid size nx and stability coefficient r.
    WHEN: Creating matrices using create_matrices.
    THEN: The matrices A and B should be square, symmetric, and of size (nx, nx).
    """
    nx = 10
    r = 0.25
    A, B = create_matrices(nx, r)

    #check dimensions
    assert A.shape == (nx, nx), "Matrix A has incorrect dimensions"
    assert B.shape == (nx, nx), "Matrix B has incorrect dimensions"
    #check symmetry
    assert np.allclose(A, A.T), "Matrix A is not symmetric"
    assert np.allclose(B, B.T), "Matrix B is not symmetric"

@pytest.mark.parametrize("nx", [5, 10, 15])
def test_apply_boundary_conditions(nx):
    """
    Test that apply_boundary_conditions correctly applies Dirichlet boundary conditions.
    
    GIVEN: A random matrix of size (nx, nx).
    WHEN: Applying Dirichlet boundary conditions using apply_boundary_conditions.
    THEN: The first and last rows should match identity boundary conditions, while other rows remain unaltered.
    """
    matrix = np.random.rand(nx, nx)
    modified_matrix = apply_boundary_conditions(matrix)

    #top row boundary condition
    assert np.array_equal(modified_matrix[0, :], np.eye(nx)[0, :]), "Boundary conditions not applied correctly at the top row"
    #bottom row boundary condition
    assert np.array_equal(modified_matrix[-1, :], np.eye(nx)[-1, :]), "Boundary conditions not applied correctly at the bottom row"
    #other rows remain unaltered
    assert np.array_equal(modified_matrix[1:-1, 1:-1], matrix[1:-1, 1:-1]), "Internal matrix rows modified incorrectly"

@pytest.mark.parametrize("parameters", numerical_cases)
def test_accuracy_against_analytical(parameters):
    """
    Test that the Crank-Nicolson solution is accurate by comparing it to the analytical solution for a given set of parameters.

    GIVEN: A set of parameters.
    WHEN: Computing the temperature distribution using both the CN method and the analytical one.
    THEN: The relative error between the two solutions should be less than the defined acceptable threshold (1e-3).
    """
    length = parameters["length"]
    nx = parameters["nx"]
    time = parameters["time"]
    nt = parameters["nt"]
    alpha = parameters["alpha"]

    #generate the numerical solution
    _, numerical_solution = heat_equation_CN(length, nx, time, nt, alpha, function_temperature)
    _, analytical_solution = heat_equation_analytical(length, nx, time, nt, alpha)
    
    #compute relative error
    error = np.linalg.norm(numerical_solution - analytical_solution) / np.linalg.norm(analytical_solution)
    
    #a reasonable threshold for accuracy
    acceptable_error = 1e-3
    
    assert error < acceptable_error, f"Numerical solution error {error:.3e} exceeds acceptable threshold {acceptable_error:.3e}."


@settings(deadline=None)
@given(
    length=st.floats(min_value=1.0, max_value=10.0),  
    nx=st.integers(min_value=25, max_value=250),
    time=st.floats(min_value=1.0, max_value=10.0),
    nt=st.integers(min_value=25, max_value=250),
    alpha=st.floats(min_value=0.01, max_value=0.5)
)
def test_simulation_convergence(length, nx, time, nt, alpha):
    """
    Test that checks both the numerical and analytical solutions.
    First, the stability condition is verified, and then that the
    numerical solution matrix and the analytical one have the same dimensions.
    In the end, it is verified that the numerical solutions match the analytical ones.
    
    GIVEN: Randomized parameters for the heat equation.
    WHEN: Solving the equation numerically and analytically.
    THEN: The solutions should match in shape and values should be close within tolerance.
    """
    deltax = length / (nx - 1)
    deltat = time / (nt - 1)
    r = alpha * deltat / deltax**2

    assume(r < 0.5)
    
    x_num, w_num = heat_equation_CN(length, nx, time, nt, alpha, function_temperature)
    x_ana, w_ana = heat_equation_analytical(length, nx, time, nt, alpha)

    assert w_num.shape == w_ana.shape, f"Shapes of numerical {w_num.shape} and analytical {w_ana.shape} solutions do not match"

    try:
        np.testing.assert_allclose(w_num, w_ana, rtol=1e-3, atol=5e-4)
    except AssertionError as e:
        print(f"Failed case:\nlength={length}, nx={nx}, time={time}, nt={nt}, alpha={alpha}")
        print(f"deltax={deltax}, deltat={deltat}, r={r}")
        raise e
